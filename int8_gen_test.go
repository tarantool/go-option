// Code generated by github.com/tarantool/go-option; DO NOT EDIT.

package option_test

import (
	"bytes"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/vmihailenco/msgpack/v5"

	"github.com/tarantool/go-option"
)

func TestInt8_IsSome(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		someInt8 := option.SomeInt8(12)
		assert.True(t, someInt8.IsSome())
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		emptyInt8 := option.NoneInt8()
		assert.False(t, emptyInt8.IsSome())
	})
}

func TestInt8_IsZero(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		someInt8 := option.SomeInt8(12)
		assert.False(t, someInt8.IsZero())
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		emptyInt8 := option.NoneInt8()
		assert.True(t, emptyInt8.IsZero())
	})
}

func TestInt8_IsNil(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		someInt8 := option.SomeInt8(12)
		assert.False(t, someInt8.IsNil())
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		emptyInt8 := option.NoneInt8()
		assert.True(t, emptyInt8.IsNil())
	})
}

func TestInt8_Get(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		someInt8 := option.SomeInt8(12)
		val, ok := someInt8.Get()
		require.True(t, ok)
		assert.EqualValues(t, 12, val)
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		emptyInt8 := option.NoneInt8()
		_, ok := emptyInt8.Get()
		require.False(t, ok)
	})
}

func TestInt8_MustGet(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		someInt8 := option.SomeInt8(12)
		assert.EqualValues(t, 12, someInt8.MustGet())
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		emptyInt8 := option.NoneInt8()
		assert.Panics(t, func() {
			emptyInt8.MustGet()
		})
	})
}

func TestInt8_Unwrap(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		someInt8 := option.SomeInt8(12)
		assert.EqualValues(t, 12, someInt8.Unwrap())
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		emptyInt8 := option.NoneInt8()
		assert.NotPanics(t, func() {
			emptyInt8.Unwrap()
		})
	})
}

func TestInt8_UnwrapOr(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		someInt8 := option.SomeInt8(12)
		assert.EqualValues(t, 12, someInt8.UnwrapOr(13))
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		emptyInt8 := option.NoneInt8()
		assert.EqualValues(t, 13, emptyInt8.UnwrapOr(13))
	})
}

func TestInt8_UnwrapOrElse(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		someInt8 := option.SomeInt8(12)
		assert.EqualValues(t, 12, someInt8.UnwrapOrElse(func() int8 {
			return 13
		}))
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		emptyInt8 := option.NoneInt8()
		assert.EqualValues(t, 13, emptyInt8.UnwrapOrElse(func() int8 {
			return 13
		}))
	})
}

func TestInt8_EncodeDecodeMsgpack(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		var buf bytes.Buffer

		enc := msgpack.NewEncoder(&buf)
		dec := msgpack.NewDecoder(&buf)

		someInt8 := option.SomeInt8(12)
		err := someInt8.EncodeMsgpack(enc)
		require.NoError(t, err)

		var unmarshaled option.Int8
		err = unmarshaled.DecodeMsgpack(dec)
		require.NoError(t, err)
		assert.True(t, unmarshaled.IsSome())
		assert.EqualValues(t, 12, unmarshaled.Unwrap())
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		var buf bytes.Buffer

		enc := msgpack.NewEncoder(&buf)
		dec := msgpack.NewDecoder(&buf)

		emptyInt8 := option.NoneInt8()
		err := emptyInt8.EncodeMsgpack(enc)
		require.NoError(t, err)

		var unmarshaled option.Int8
		err = unmarshaled.DecodeMsgpack(dec)

		require.NoError(t, err)
		assert.False(t, unmarshaled.IsSome())
	})
}
