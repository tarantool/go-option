package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"slices"
	"text/template"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

const (
	defaultGoPermissions = 0644
)

var (
	outputDirectory string
	verbose         bool
)

type generatorDef struct {
	Name        string
	Type        string
	DecodeFunc  string
	EncoderFunc string
	CheckerFunc string

	TestingValue           string
	UnexpectedTestingValue string
}

func structToMap(def generatorDef) map[string]interface{} {
	caser := cases.Title(language.English)

	out := map[string]interface{}{
		"Name":        caser.String(def.Name),
		"Type":        def.Name,
		"DecodeFunc":  def.DecodeFunc,
		"EncoderFunc": def.EncoderFunc,
		"CheckerFunc": def.CheckerFunc,

		"TestingValue":           def.TestingValue,
		"UnexpectedTestingValue": def.UnexpectedTestingValue,
	}

	if def.Type != "" {
		out["Type"] = def.Type
	}

	return out
}

var defaultTypes = []generatorDef{
	{
		Name:        "byte",
		Type:        "byte",
		DecodeFunc:  "decodeByte",
		EncoderFunc: "encodeByte",
		CheckerFunc: "checkNumber",

		TestingValue:           "12",
		UnexpectedTestingValue: "13",
	},
	{
		Name:        "int",
		Type:        "int",
		DecodeFunc:  "decodeInt",
		EncoderFunc: "encodeInt",
		CheckerFunc: "checkNumber",

		TestingValue:           "12",
		UnexpectedTestingValue: "13",
	},
	{
		Name:        "int8",
		Type:        "int8",
		DecodeFunc:  "decodeInt8",
		EncoderFunc: "encodeInt8",
		CheckerFunc: "checkNumber",

		TestingValue:           "12",
		UnexpectedTestingValue: "13",
	},
	{
		Name:        "int16",
		Type:        "int16",
		DecodeFunc:  "decodeInt16",
		EncoderFunc: "encodeInt16",
		CheckerFunc: "checkNumber",

		TestingValue:           "12",
		UnexpectedTestingValue: "13",
	},
	{
		Name:        "int32",
		Type:        "int32",
		DecodeFunc:  "decodeInt32",
		EncoderFunc: "encodeInt32",
		CheckerFunc: "checkNumber",

		TestingValue:           "12",
		UnexpectedTestingValue: "13",
	},
	{
		Name:        "int64",
		Type:        "int64",
		DecodeFunc:  "decodeInt64",
		EncoderFunc: "encodeInt64",
		CheckerFunc: "checkNumber",

		TestingValue:           "12",
		UnexpectedTestingValue: "13",
	},
	{
		Name:        "uint",
		Type:        "uint",
		DecodeFunc:  "decodeUint",
		EncoderFunc: "encodeUint",
		CheckerFunc: "checkNumber",

		TestingValue:           "12",
		UnexpectedTestingValue: "13",
	},
	{
		Name:        "uint8",
		Type:        "uint8",
		DecodeFunc:  "decodeUint8",
		EncoderFunc: "encodeUint8",
		CheckerFunc: "checkNumber",

		TestingValue:           "12",
		UnexpectedTestingValue: "13",
	},
	{
		Name:        "uint16",
		Type:        "uint16",
		DecodeFunc:  "decodeUint16",
		EncoderFunc: "encodeUint16",
		CheckerFunc: "checkNumber",

		TestingValue:           "12",
		UnexpectedTestingValue: "13",
	},
	{
		Name:        "uint32",
		Type:        "uint32",
		DecodeFunc:  "decodeUint32",
		EncoderFunc: "encodeUint32",
		CheckerFunc: "checkNumber",

		TestingValue:           "12",
		UnexpectedTestingValue: "13",
	},
	{
		Name:        "uint64",
		Type:        "uint64",
		DecodeFunc:  "decodeUint64",
		EncoderFunc: "encodeUint64",
		CheckerFunc: "checkNumber",

		TestingValue:           "12",
		UnexpectedTestingValue: "13",
	},
	{
		Name:        "float32",
		Type:        "float32",
		DecodeFunc:  "decodeFloat32",
		EncoderFunc: "encodeFloat32",
		CheckerFunc: "checkFloat",

		TestingValue:           "12",
		UnexpectedTestingValue: "13",
	},
	{
		Name:        "float64",
		Type:        "float64",
		DecodeFunc:  "decodeFloat64",
		EncoderFunc: "encodeFloat64",
		CheckerFunc: "checkFloat",

		TestingValue:           "12",
		UnexpectedTestingValue: "13",
	},
	{
		Name:        "string",
		Type:        "string",
		DecodeFunc:  "decodeString",
		EncoderFunc: "encodeString",
		CheckerFunc: "checkString",

		TestingValue:           "\"hello\"",
		UnexpectedTestingValue: "\"henlo\"",
	},
	{
		Name:        "bytes",
		Type:        "[]byte",
		DecodeFunc:  "decodeBytes",
		EncoderFunc: "encodeBytes",
		CheckerFunc: "checkBytes",

		TestingValue:           "[]byte(\"hello\")",
		UnexpectedTestingValue: "[]byte(\"henlo\")",
	},
	{
		Name:        "bool",
		Type:        "bool",
		DecodeFunc:  "decodeBool",
		EncoderFunc: "encodeBool",
		CheckerFunc: "checkBool",

		TestingValue:           "true",
		UnexpectedTestingValue: "false",
	},
}

var tplText = `
// Code generated by github.com/tarantool/go-option; DO NOT EDIT.

package {{ .packageName }}

import (
	{{ range $i, $import := .imports }}
	"{{ $import }}"
	{{ end }}

	"github.com/vmihailenco/msgpack/v5"
	"github.com/vmihailenco/msgpack/v5/msgpcode"
)

// {{.Name}} represents an optional value of type {{.Type}}.
// It can either hold a valid {{.Type}} (IsSome == true) or be empty (IsZero == true).
type {{.Name}} struct {
	value  {{.Type}}
	exists bool
}

// Some{{.Name}} creates an optional {{.Name}} with the given {{.Type}} value.
// The returned {{.Name}} will have IsSome() == true and IsZero() == false.
//
// Example:
//
//	o := Some{{.Name}}({{.TestingValue}})
//	if o.IsSome() {
//	    v := o.Unwrap() // v == {{.TestingValue}}
//	}
func Some{{.Name}}(value {{.Type}}) {{.Name}} {
	return {{.Name}}{
		value: value,
		exists: true,
	}
}

// None{{.Name}} creates an empty optional {{.Name}} value.
// The returned {{.Name}} will have IsSome() == false and IsZero() == true.
//
// Example:
//
//	o := None{{.Name}}()
//	if o.IsZero() {
//	    fmt.Println("value is absent")
//	}
func None{{.Name}}() {{.Name}} {
	return {{.Name}}{
		exists: false,
		value:  zero[{{.Type}}](),
	}
}

// IsSome returns true if the {{.Name}} contains a value.
// This indicates the value is explicitly set (not None).
func (o {{.Name}}) IsSome() bool {
	return o.exists
}

// IsZero returns true if the {{.Name}} does not contain a value.
// Equivalent to !IsSome(). Useful for consistency with types where
// zero value (e.g. 0, false, zero struct) is valid and needs to be distinguished.
func (o {{.Name}}) IsZero() bool {
	return !o.exists
}

// IsNil is an alias for IsZero.
//
// This method is provided for compatibility with the msgpack Encoder interface.
func (o {{.Name}}) IsNil() bool {
	return o.IsZero()
}

// Get returns the stored value and a boolean flag indicating its presence.
// If the value is present, returns (value, true).
// If the value is absent, returns (zero value of {{.Type}}, false).
//
// Recommended usage:
//
//	if value, ok := o.Get(); ok {
//	    // use value
//	}
func (o {{.Name}}) Get() ({{.Type}}, bool) {
	return o.value, o.exists
}

// MustGet returns the stored value if it is present.
// Panics if the value is absent (i.e., IsZero() == true).
//
// Use with caution â€” only when you are certain the value exists.
//
// Panics with: "optional value is not set" if no value is set.
func (o {{.Name}}) MustGet() {{.Type}} {
	if !o.exists {
		panic("optional value is not set")
	}

	return o.value
}

// Unwrap returns the stored value regardless of presence.
// If no value is set, returns the zero value for {{.Type}}.
//
// Warning: Does not check presence. Use IsSome() before calling if you need
// to distinguish between absent value and explicit zero value.
func (o {{.Name}}) Unwrap() {{.Type}} {
	return o.value
}

// UnwrapOr returns the stored value if present.
// Otherwise, returns the provided default value.
//
// Example:
//
//	o := None{{.Name}}()
//	v := o.UnwrapOr(someDefault{{.Name}})
func (o {{.Name}}) UnwrapOr(defaultValue {{.Type}}) {{.Type}} {
	if o.exists {
		return o.value
	}

	return defaultValue
}

// UnwrapOrElse returns the stored value if present.
// Otherwise, calls the provided function and returns its result.
// Useful when the default value requires computation or side effects.
//
// Example:
//
//	o := None{{.Name}}()
//	v := o.UnwrapOrElse(func() {{.Type}} { return computeDefault() })
func (o {{.Name}}) UnwrapOrElse(defaultValue func() {{.Type}}) {{.Type}} {
	if o.exists {
		return o.value
	}

	return defaultValue()
}

// EncodeMsgpack encodes the {{.Name}} value using MessagePack format.
// - If the value is present, it is encoded as {{.Type}}.
// - If the value is absent (None), it is encoded as nil.
//
// Returns an error if encoding fails.
func (o {{.Name}}) EncodeMsgpack(encoder *msgpack.Encoder) error {
	if o.exists {
		return newEncodeError("{{.Name}}", {{ .EncoderFunc }}(encoder, o.value))
	}

	return newEncodeError("{{.Name}}", encoder.EncodeNil())
}

// DecodeMsgpack decodes a {{.Name}} value from MessagePack format.
// Supports two input types:
//   - nil: interpreted as no value (None{{.Name}})
//   - {{.Type}}: interpreted as a present value (Some{{.Name}})
//
// Returns an error if the input type is unsupported or decoding fails.
//
// After successful decoding:
//   - on nil: exists = false, value = default zero value
//   - on {{.Type}}: exists = true, value = decoded value
func (o *{{.Name}}) DecodeMsgpack(decoder *msgpack.Decoder) error {
	code, err := decoder.PeekCode()
	if err != nil {
		return newDecodeError("{{.Name}}", err)
	}

	switch {
	case code == msgpcode.Nil:
		o.exists = false

		return newDecodeError("{{.Name}}", decoder.Skip())
	case {{ .CheckerFunc }}(code):
		o.value, err = {{ .DecodeFunc }}(decoder)
		if err != nil {
			return newDecodeError("{{.Name}}", err)
		}
		o.exists = true

		return err
	default:
		return newDecodeWithCodeError("{{.Name}}", code)
	}
}`

var tplTestText = `
// Code generated by github.com/tarantool/go-option; DO NOT EDIT.

package {{ .packageName }}_test

import (
	{{ range $i, $import := .imports }}
	"{{ $import }}"
	{{ end }}

	"bytes"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/vmihailenco/msgpack/v5"

	"github.com/tarantool/go-option"
)

func Test{{.Name}}_IsSome(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		some{{.Name}} := option.Some{{.Name}}({{.TestingValue}})
		assert.True(t, some{{.Name}}.IsSome())
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		empty{{.Name}} := option.None{{.Name}}()
		assert.False(t, empty{{.Name}}.IsSome())
	})
}

func Test{{.Name}}_IsZero(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		some{{.Name}} := option.Some{{.Name}}({{.TestingValue}})
		assert.False(t, some{{.Name}}.IsZero())
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		empty{{.Name}} := option.None{{.Name}}()
		assert.True(t, empty{{.Name}}.IsZero())
	})
}

func Test{{.Name}}_IsNil(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		some{{.Name}} := option.Some{{.Name}}({{.TestingValue}})
		assert.False(t, some{{.Name}}.IsNil())
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		empty{{.Name}} := option.None{{.Name}}()
		assert.True(t, empty{{.Name}}.IsNil())
	})
}

func Test{{.Name}}_Get(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		some{{.Name}} := option.Some{{.Name}}({{.TestingValue}})
		val, ok := some{{.Name}}.Get()
		require.True(t, ok)
		assert.EqualValues(t, {{.TestingValue}}, val)
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		empty{{.Name}} := option.None{{.Name}}()
		_, ok := empty{{.Name}}.Get()
		require.False(t, ok)
	})
}

func Test{{.Name}}_MustGet(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		some{{.Name}} := option.Some{{.Name}}({{.TestingValue}})
		assert.EqualValues(t, {{.TestingValue}}, some{{.Name}}.MustGet())
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		empty{{.Name}} := option.None{{.Name}}()
		assert.Panics(t, func() {
			empty{{.Name}}.MustGet()
		})
	})
}

func Test{{.Name}}_Unwrap(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		some{{.Name}} := option.Some{{.Name}}({{.TestingValue}})
		assert.EqualValues(t, {{.TestingValue}}, some{{.Name}}.Unwrap())
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		empty{{.Name}} := option.None{{.Name}}()
		assert.NotPanics(t, func() {
			empty{{.Name}}.Unwrap()
		})
	})
}

func Test{{.Name}}_UnwrapOr(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		some{{.Name}} := option.Some{{.Name}}({{.TestingValue}})
		assert.EqualValues(t, {{.TestingValue}}, some{{.Name}}.UnwrapOr({{.UnexpectedTestingValue}}))
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		empty{{.Name}} := option.None{{.Name}}()
		assert.EqualValues(t, {{.UnexpectedTestingValue}}, empty{{.Name}}.UnwrapOr({{.UnexpectedTestingValue}}))
	})
}

func Test{{.Name}}_UnwrapOrElse(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		some{{.Name}} := option.Some{{.Name}}({{.TestingValue}})
		assert.EqualValues(t, {{.TestingValue}}, some{{.Name}}.UnwrapOrElse(func() {{.Type}} {
			return {{.UnexpectedTestingValue}}
		}))
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		empty{{.Name}} := option.None{{.Name}}()
		assert.EqualValues(t, {{.UnexpectedTestingValue}}, empty{{.Name}}.UnwrapOrElse(func() {{.Type}} {
			return {{.UnexpectedTestingValue}}
		}))
	})
}

func Test{{.Name}}_EncodeDecodeMsgpack(t *testing.T) {
	t.Parallel()

	t.Run("some", func(t *testing.T) {
		t.Parallel()

		var buf bytes.Buffer

		enc := msgpack.NewEncoder(&buf)
		dec := msgpack.NewDecoder(&buf)

		some{{.Name}} := option.Some{{.Name}}({{.TestingValue}})
		err := some{{.Name}}.EncodeMsgpack(enc)
		require.NoError(t, err)

		var unmarshaled option.{{.Name}}
		err = unmarshaled.DecodeMsgpack(dec)
		require.NoError(t, err)
		assert.True(t, unmarshaled.IsSome())
		assert.EqualValues(t, {{.TestingValue}}, unmarshaled.Unwrap())
	})

	t.Run("none", func(t *testing.T) {
		t.Parallel()

		var buf bytes.Buffer

		enc := msgpack.NewEncoder(&buf)
		dec := msgpack.NewDecoder(&buf)

		empty{{.Name}} := option.None{{.Name}}()
		err := empty{{.Name}}.EncodeMsgpack(enc)
		require.NoError(t, err)

		var unmarshaled option.{{.Name}}
		err = unmarshaled.DecodeMsgpack(dec)

		require.NoError(t, err)
		assert.False(t, unmarshaled.IsSome())
	})
}
`

func printFile(prefix string, data []byte) {
	for lineNo, line := range bytes.Split(data, []byte("\n")) {
		fmt.Printf("%03d%s%s\n", lineNo, prefix, string(line))
	}
}

func generateAndWrite() error {
	tmpl, err := template.New("internal").Parse(tplText)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	tmpl_test, err := template.New("internal_test").Parse(tplTestText)
	if err != nil {
		return fmt.Errorf("failed to parse testing template: %w", err)
	}

	outputData := make(map[string][]byte, 2*len(defaultTypes)) //nolint:mnd

	var data bytes.Buffer

	// 1. Generate code for each type.
	for _, generatedType := range defaultTypes {
		tmplData := structToMap(generatedType)

		tmplData["packageName"] = "option" // Package name is option, since generator is used for option only right now.
		tmplData["imports"] = []string{}   // No additional imports are needed right now.

		// Generate code of an Optional type.
		{
			err := tmpl.Execute(&data, tmplData)
			if err != nil {
				return fmt.Errorf("failed to execute template: %w", err)
			}

			outputData[generatedType.Name+"_gen.go"] = slices.Clone(data.Bytes())
			data.Reset()
		}

		// Generate code for tests of an Optional type.
		{
			err := tmpl_test.Execute(&data, tmplData)
			if err != nil {
				return fmt.Errorf("failed to execute test template: %w", err)
			}

			outputData[generatedType.Name+"_gen_test.go"] = slices.Clone(data.Bytes())
			data.Reset()
		}
	}

	// 2. Just in case format code using gofmt.
	for name, origData := range outputData {
		data, err := format.Source(origData)
		if err != nil {
			if verbose {
				printFile("> ", origData)
			}

			return fmt.Errorf("failed to format code: %w", err)
		}

		outputData[name] = data
	}

	// 3. Write resulting code to files.
	for name, data := range outputData {
		err = os.WriteFile(filepath.Join(outputDirectory, name), data, defaultGoPermissions)
		if err != nil {
			return fmt.Errorf("failed to write file: %w", err)
		}
	}

	return nil
}

func main() {
	flag.StringVar(&outputDirectory, "output", ".", "output directory")
	flag.BoolVar(&verbose, "verbose", false, "print verbose output")
	flag.Parse()

	// Get absolute path for output directory.
	absOutputDirectory, err := filepath.Abs(outputDirectory)
	if err != nil {
		fmt.Printf("failed to get absolute path for output directory (%s): %s\n", outputDirectory, err)
		os.Exit(1)
	}

	// Check if output directory exists and is directory.
	switch fInfo, err := os.Stat(absOutputDirectory); {
	case err != nil:
		fmt.Println("failed to stat output directory: ", err.Error())
		os.Exit(1)
	case !fInfo.IsDir():
		fmt.Printf("output directory '%s' is not a directory\n", absOutputDirectory)
		os.Exit(1)
	}

	err = generateAndWrite()
	if err != nil {
		fmt.Println("failed to generate or write code: ", err)
		os.Exit(1)
	}
}
